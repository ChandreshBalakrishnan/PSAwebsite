<!DOCTYPE html>
<html lang="en">
<head>
  <link rel="icon" type="image/png" href="favicon.png">
  <meta charset="UTF-8" />
  <title>PSA-0108-01</title>
  <link rel="stylesheet" href="style.css" />
</head>

<body>

  <div class="tabs">
    <a class="tab" href="index.html">Prototype Overview</a>
    <a class="tab" href="prototypedesign.html">Prototype Design</a>
    <a class="tab active" href="build.html">Build</a>
    <a class="tab" href="integration.html">Integration</a>
    <a class="tab" href="verification.html">Verification</a>
    <a class="tab" href="downloads.html">Downloads</a>
  </div>

  <div class="tabs sub-tabs">
    <a class="tab" href="electrical.html">Electrical</a>
    <a class="tab active" href="software.html">Software</a>
    <a class="tab" href="structural.html">Structural</a>
    <a class="tab" href="purchaseorders.html">PurchaseOrders</a>
    <a class="tab" href="model-viewer.html?model=models/model1.glb">
      BreadboardCase_v1 3D Model
    </a>

    <a class="tab" href="model-viewer.html?model=models/model2.glb">
      BreadboardCase_v2 3D Model
    </a>
  </div>



  <main class="report">
    <h1 style="text-align:center;">Software Design
    </h1>

    <p>
      The software subsystem progressed through three iterative versions, each developed to address behavioral and state-accessibility limitations identified during testing. For every iteration, a corresponding Finite State Machine (FSM) was created to formally represent system logic, evaluate state connectivity, and inform refinements to the button interaction strategy. This co-development of code and FSMs enabled a structured transition from limited, mode-specific control toward a fully accessible and robust state-navigation scheme.
    </p>

    <p>
      The first software iteration implements a two-button control scheme intended to establish baseline system functionality. One button cycles forward through the allowable LED modes, while the second button immediately transitions the system to an OFF state by turning all LEDs off. While this approach provides a clear and simple shutdown mechanism, the accompanying FSM reveals limitations in state accessibility, as certain operating modes cannot be reached directly from the OFF state using a single button press. These constraints motivated further refinement in subsequent iterations.
    </p>

    <pre class="code-block"><code>
'''
PSA CircuitPython code
One button cycles between the number of LEDs that will be on
One button shuts off all the LEDs to turn them all off
With both buttons you are able to cycle between any LED mode you desire, while having
the flexibility to turn off all LEDs with one button press
However, this implementation has the downside of not being able 
to go from the OFF state to the 3LED state with a signle button press
'''

# import libraries needed to initialize board, LEDs, and buttons
import board
import digitalio
import time

# initialize a cycle counter to cycle between the LED modes
cycle_counter = 0

# initialize the green, blue, and red LEDs with their corresponding GPIO pins
green = digitalio.DigitalInOut(board.GP18)
green.direction = digitalio.Direction.OUTPUT

blue = digitalio.DigitalInOut(board.GP17)
blue.direction = digitalio.Direction.OUTPUT

red = digitalio.DigitalInOut(board.GP16)
red.direction = digitalio.Direction.OUTPUT

# initialize the cycle and shut buttons with their corresponding GPIO pins
cycle = digitalio.DigitalInOut(board.GP15)
cycle.direction = digitalio.Direction.INPUT
cycle.pull = digitalio.Pull.UP

shut = digitalio.DigitalInOut(board.GP14)
shut.direction = digitalio.Direction.INPUT
shut.pull = digitalio.Pull.UP 

# print statement to verify code is running
print('Hello!')

# infinite loop
while True:
    # when shut button is pressed
    if (not shut.value):
        cycle_counter = 0
        green.value = False
        blue.value = False
        red.value = False
        # allows sleep time to eliminate button bouncing 
        while not shut.value: 
            time.sleep(0.01)
        time.sleep(0.05)
    
    # when cycle button is pressed
    elif (not cycle.value):
        if(cycle_counter != 2):
            cycle_counter = cycle_counter + 1
            # turn red and blue on (PLANTS ONLY)
            if(cycle_counter == 1):
                red.value = True
                blue.value = True
                green.value = False
            # turn red, blue, and green on (PLANTS & PEOPLE)
            elif(cycle_counter == 2):
                red.value = True
                blue.value = True
                green.value = True
        else:
            cycle_counter = 1
            green.value = False
            blue.value = True
            red.value = True
        # allows sleep time to eliminate button bouncing 
        while not cycle.value: 
            time.sleep(0.01)
        time.sleep(0.05)     
    
    time.sleep(0.01)
            
    </code></pre>
    <figure class="media-figure">
      <img src="media/software/FSM_v1.png" alt="FSM for v1 of CircuitPython code">
      <figcaption>
        Figure 1
      </figcaption>
    </figure>

    <p>
      The second software iteration explores an alternative interaction strategy by assigning distinct functions to each button. One button activates a two-LED (PLANTS ONLY) mode, while the other activates a three-LED (PLANTS and PEOPLE) mode. If any LEDs are already illuminated, pressing either button transitions the system back to the OFF state. This design improves direct access to specific modes from OFF, as illustrated by the corresponding FSM, but introduces new limitations by preventing direct transitions between the two-LED and three-LED states without first returning to OFF. This trade-off highlighted the balance between simplicity and state connectivity.
    </p>

     <pre class="code-block"><code>
'''
PSA CircuitPython code
One button, two_light_buttons, turns on the Red and Blue LEDs if all LEDs are currently off
One button three_light_buttons, turns on all the LEDs if all LEDs are currently off.
If any LEDs are on, either button turns them all off
This implementation of the PSA CircuitPython code ensures you can reach any other state from the OFF state, 
but has the downside of not being able to go from the 2LED to the 3LED state and vice-versa in a single button push.
'''

# import libraries needed to initialize board, LEDs, and buttons
import board
import digitalio
import time

# initialize the green, blue, and red LEDs with their corresponding GPIO pins
green = digitalio.DigitalInOut(board.GP18)
green.direction = digitalio.Direction.OUTPUT

blue = digitalio.DigitalInOut(board.GP17)
blue.direction = digitalio.Direction.OUTPUT

red = digitalio.DigitalInOut(board.GP16)
red.direction = digitalio.Direction.OUTPUT

# initialize the two_light_button and three_light_button buttons with their corresponding GPIO pins
two_light_button = digitalio.DigitalInOut(board.GP15)
two_light_button.direction = digitalio.Direction.INPUT
two_light_button.pull = digitalio.Pull.UP

three_light_button = digitalio.DigitalInOut(board.GP14)
three_light_button.direction = digitalio.Direction.INPUT
three_light_button.pull = digitalio.Pull.UP 

# print statement to verify code is running
print('Hello!')

# infinite loop
while True:
    # when both buttons are pressed, the three_light_button takes priority
    if (not two_light_button.value and not three_light_button.value):
        # turn all LEDs on
        red.value = True
        blue.value = True
        green.value = True
        # prevent button bouncing
        while not two_light_button.value: 
            time.sleep(0.01)
        while not three_light_button.value: 
            time.sleep(0.01)
        time.sleep(0.05)
    elif (not three_light_button.value):
        # if any LEDs are on, turn them all off
        if(red.value == True or blue.value == True or green.value == True):
            green.value = False
            blue.value = False
            red.value = False
        else:
            # else, turn all LEDs on
            red.value = True
            blue.value = True
            green.value = True
        # prevent button bouncing
        while not three_light_button.value: 
            time.sleep(0.01)
        time.sleep(0.05)
    
    elif (not two_light_button.value):
        # if any LEDs on, turn them all off
        if(red.value == True or blue.value == True or green.value == True):
            green.value = False
            blue.value = False
            red.value = False
        else:
            # turn red and blue LEDs on
            red.value = True
            blue.value = True
            green.value = False
        # prevent button bouncing
        while not two_light_button.value: 
            time.sleep(0.01)
        time.sleep(0.05)

    time.sleep(0.01)
            
    </code></pre>
    <figure class="media-figure">
      <img src="media/software/FSM_v2.png" alt="FSM for v2 of CircuitPython code">
      <figcaption>
        Figure 2
      </figcaption>
    </figure>

    <p>
      The final software version represents a fully refined control strategy that resolves the limitations identified in earlier iterations. In this implementation, one button advances the system forward through the available states, while the second button cycles backward through the same states. The state progression is circular, such that the forward button transitions through the sequence 0--2--3 and returns to 0, while the reverse button transitions through 3--2--0 and returns to 3. The corresponding FSM demonstrates complete and symmetric state accessibility, ensuring that any operating mode can be reached from any other mode with a single button press. This iteration reflects a mature and robust interaction design.
    </p>

     <pre class="code-block"><code>
'''
PSA CircuitPython code
One button cycles forward between the states, OFF, 1LED, 2LED.
The other button cycles backward between the states.
This implementation of the PSA CircuitPython code takes advantage of 2 buttons,
ensuring that every state can be reached with a single button press.
'''

# import libraries needed to initialize board, LEDs, and buttons
import board
import digitalio
import time

# initialize a cycle counter to cycle between the LED modes
cycle_counter = 0

# initialize the green, blue, and red LEDs with their corresponding GPIO pins
green = digitalio.DigitalInOut(board.GP17)
green.direction = digitalio.Direction.OUTPUT

blue = digitalio.DigitalInOut(board.GP21)
blue.direction = digitalio.Direction.OUTPUT

red = digitalio.DigitalInOut(board.GP18)
red.direction = digitalio.Direction.OUTPUT

# initialize the reverse and forward buttons with their corresponding GPIO pins
reverse = digitalio.DigitalInOut(board.GP15)
reverse.direction = digitalio.Direction.INPUT
reverse.pull = digitalio.Pull.UP

forward = digitalio.DigitalInOut(board.GP14)
forward.direction = digitalio.Direction.INPUT
forward.pull = digitalio.Pull.UP 

# print statement to verify code is running
print('Hello!')

# infinite loop
while True:
    # when reverse button is pressed
    if (not reverse.value):
        if(cycle_counter != 0):
            cycle_counter = cycle_counter - 1
            if(cycle_counter == 1):
                red.value = True
                blue.value = True
                green.value = False
            # turn red, blue, and green on (PLANTS & PEOPLE)
            elif(cycle_counter == 0):
                red.value = False
                blue.value = False
                green.value = False
        else:
            # turn red, blue, and green on (PLANTS & PEOPLE)
            cycle_counter = 2
            green.value = True
            blue.value = True
            red.value = True
            
        # allows sleep time to eliminate button bouncing 
        while not reverse.value: 
            time.sleep(0.01)
        time.sleep(0.05)
    
    # when forward button is pressed
    elif (not forward.value):
        if(cycle_counter != 2):
            cycle_counter = cycle_counter + 1
            # turn red and blue on (PLANTS ONLY)
            if(cycle_counter == 1):
                red.value = True
                blue.value = True
                green.value = False
            # turn red, blue, and green on (PLANTS & PEOPLE)
            elif(cycle_counter == 2):
                red.value = True
                blue.value = True
                green.value = True
        else:
            cycle_counter = 0
            green.value = False
            blue.value = False
            red.value = False
        # allows sleep time to eliminate button bouncing 
        while not forward.value: 
            time.sleep(0.01)
        time.sleep(0.05)     
    
    time.sleep(0.01)
            
    </code></pre>
    <figure class="media-figure">
      <img src="media/software/FSM_v3.png" alt="FSM for v3 of CircuitPython code">
      <figcaption>
        Figure 3
      </figcaption>
    </figure>

    <h1 style="text-align:center;">Software Design Summary
    </h1>
    <p>
      The final software system synthesized lessons from all three iterations and their corresponding FSMs. Version 1 provided a simple two-button scheme that highlighted state accessibility limitations. Version 2 improved direct access to the two-LED and three-LED modes, revealing trade-offs between simplicity and mode connectivity. Version 3 implemented circular forward and backward transitions between all states, ensuring symmetric access. By combining the clear mode separation of Version 2 with the full state accessibility of Version 3, the final software design allows users to navigate between LED modes intuitively, supports the physical button layout determined in the electrical prototypes, and seamlessly integrates with the enclosureâ€™s intended interaction points.
    </p>
    <!-- Add as much text as you want -->
  </main>
</body>
</html>
